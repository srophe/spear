<?xml version="1.0" encoding="UTF-8"?>
<TEI 
  xmlns:sch="http://purl.oclc.org/dsdl/schematron"
  xmlns="http://www.tei-c.org/ns/1.0">
  
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI Customization for SPEAR: Syriaca Persons, Events, and Relations</title>
        <editor role="creator"><name ref="http://syriaca.org/documentation/editors.xml#dschwartz">Daniel L.
            Schwartz</name></editor>
      </titleStmt>
      <editionStmt>
        <edition n="1.0"/>
      </editionStmt>
      <publicationStmt>
        <publisher>Syriaca.org: The Syriac Reference Portal</publisher>
        <availability>
          <licence target="http://creativecommons.org/licenses/by/3.0/">
            <p>Distributed under a Creative Commons Attribution 3.0 Unported License.</p>
            <p>The code examples contained in <gi>exemplum</gi> elements below come from 
              Syriaca.org projects that have been distributed under a Creative Commons Attribution 
              3.0 Unported License. Used by permission.</p>
            <p>The comments on element and attribute use contained in <gi>remarks</gi> elements below 
              share some text with other Syriaca.org documentation distributed under a Creative Commons 
              Attributiion 3.0 Unported License. This documentation can be found at various links available here:
              <ref target="http://syriaca.org/documentation/index.html">http://syriaca.org/documentation/index.html</ref>
              Used by permission.
            </p>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>This ODD provides a customization of the TEI P5 All.</p>
      </sourceDesc>
    </fileDesc>
    <revisionDesc>
      <change who="http://syriaca.org/documentation/editors.xml#dschwartz" when="2016-10-20">First
        draft</change>
    </revisionDesc>
  </teiHeader>
  <text>
    <body>

      <p>This schema has been created to to constrain the TEI P5 for validating the born-digital
        project SPEAR: Syriac Persons, Events, and Relations. This customization will be used for
        the encoding of many different documents by many different researchers having differnet
        levels of training. As such, a schema is particularly important. The highly-structured data
        model of SPEAR also requires some modifications and additions to TEI P5.</p>

      <schemaSpec ident="SPEAR" start="TEI">
        <moduleRef key="core"
          include="author bibl biblScope choice citedRange corr date desc editor head listBibl name note num orig p ptr publisher pubPlace ref reg resp respStmt rs sic title"/>
        <moduleRef key="tei"/>
        <moduleRef key="header" include="authority availability catDesc category change classDecl edition editionStmt editorialDecl encodingDesc fileDesc funder idno licence profileDesc publicationStmt revisionDesc seriesStmt sourceDesc sponsor taxonomy teiHeader titleStmt"/>
        <moduleRef key="linking" include="ab"/>
        <moduleRef key="textstructure" include="back body TEI text"/>
        <moduleRef key="namesdates"
          include="birth death education event langKnowledge langKnown listEvent listPerson listRelation nationality occupation orgName persName person personGrp placeName relation residence socecStatus state trait"/>
 
                
        <classSpec type="atts" ident="att.global.analytic" mode="add">
          <desc>I have needed to include this because it somehow disappeared from this
            customization. I do not know why this was necessary.</desc>
          <attList>
            <attDef ident="ana" mode="add">
              <datatype>
                <dataRef key="teidata.text"/>
              </datatype>
              <constraintSpec ident="anaTokens" scheme="schematron">
                <constraint>
                  <sch:rule context="//tei:ab/tei:listEvent/tei:event/@ana | //tei:langKnown/@ana | //tei:occupation/@ana | //tei:socecStatus/@ana | //tei:state/@ana | //tei:trait/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:assert test="
                      every $i in $anaTokens
                      satisfies matches($i, concat('http://syriaca.org/keyword/', '\w+'))" role="error">
                      Each @ana attribute value must start with "http://syriaca.org/keyword/" and multiple 
                      values must be space separated.
                    </sch:assert>
                    <sch:assert test="count(distinct-values($anaTokens)) = count($anaTokens)" role="error">
                      The same keyword URI may not appear twice as the value of the @ana attribute. </sch:assert>
                    <sch:report test="contains(., ',') or contains(., ';')">
                      Multiple @ana attributes should be separated with one blank space
                    </sch:report>
                    <sch:report test="
                      every $i in $anaTokens
                      satisfies contains(substring-after($i, 'http://syriaca.org/keyword'), 'http:')" role="error">
                      Multiple @ana attributes should be separated with one blank space
                    </sch:report>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        

        <elementSpec ident="teiHeader" module="header" mode="change">
          <content>
            <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
              <elementRef key="fileDesc" minOccurs="1" maxOccurs="1"/>
              <elementRef key="encodingDesc" minOccurs="1" maxOccurs="1"/>
              <elementRef key="profileDesc" minOccurs="1" maxOccurs="1"/>
              <elementRef key="revisionDesc" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
          <remarks>
            <p> Every <gi>teiHeader</gi> contains a <gi>fileDesc</gi> (information
              about the creation of a file), an <gi>encodingDesc</gi> (editorial rules), a
              <gi>profileDesc</gi>> (non-bibliographic aspects of a text), and a
              <gi>revisionDesc</gi> (history of revisions). </p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="fileDesc" module="header" mode="change">
          <content>
            <sequence preserveOrder="true">
              <elementRef key="titleStmt" minOccurs="1" maxOccurs="1"/>
              <elementRef key="editionStmt" minOccurs="1" maxOccurs="1"/>
              <elementRef key="publicationStmt" minOccurs="1" maxOccurs="1"/>
              <elementRef key="seriesStmt" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="sourceDesc" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
          <remarks>
            <p> Each <gi>fileDesc</gi> contains (in order) a <gi>titleStmt</gi>, an
              <gi>editionStmt</gi>, a <gi>publicationStmt</gi>, an optional <gi>seriesStmt</gi>, and a <gi>sourceDesc</gi>. </p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="titleStmt" module="header" mode="change">
          <content>
            <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
              <elementRef key="title" minOccurs="2" maxOccurs="2"/>
              <elementRef key="sponsor" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="funder" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="editor" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="respStmt" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <constraintSpec ident="titleInTitleStmt" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:titleStmt/tei:title[1]">
                <sch:assert test="@level='m' or @level='a'">
                  The first &lt;title&gt; element child of &lt;titleStmt&gt; must have 
                  @level attribute with a value of "m" indicating "monographic" or "a" indicating
                  analytic.
                </sch:assert>
                <sch:assert test="@type='main'">
                  The first &lt;title&gt; element child of &lt;titleStmt&gt; must have 
                  @type attribute with a value of "main".
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:titleStmt/tei:title[2]">
                <sch:assert test="@type='sub'">
                  The second &lt;title&gt; element child of &lt;titleStmt&gt; must have 
                  @type attribute with a value of "sub".
                </sch:assert>
                <sch:assert test="normalize-space(.) = 'A SPEAR Prosopography'">
                  The text node of this subtitle must be "A SPEAR Prosopography".
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          
        </elementSpec>
        
        <elementSpec ident="sponsor" module="header" mode="change"><!-- text node should not validate if blank -->
          <content>
            <textNode/>
          </content>
          
          <remarks>
            <p> The TEI guidelines recommend that the <gi>titleStmt</gi> element also indicate who
              is responsible for this TEI file. Since <gi>author</gi> is typically used for the
              author of a print or manuscript text which was then encoded in TEI, we avoid the use
              of the <gi>author</gi> element. Instead, we identify Syriaca.org as the sponsoring
              institution.</p>
          </remarks>
        </elementSpec>
        
        
        
        <!-- respStmt and resp not working. Try again later.
        <elementSpec ident="respStmt" module="core">
          <content>
            <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
              <elementRef key="resp" minOccurs="1" maxOccurs="1"/>
              <elementRef key="name" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
        </elementSpec>
        
        
        <elementSpec ident="resp" module="core">
          <content>
            <textNode/>
          </content>
        </elementSpec>
        -->
        
        
        <elementSpec ident="name" module="core" mode="change">
          <constraintSpec ident="refOnName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:titleStmt/tei:respStmt/tei:name">
                <sch:assert test="@ref">
                  A @ref attribute is required.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:titleStmt/tei:respStmt/tei:name/@ref">
                <sch:let name="edsDoc"
                  value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/editors.xml')"/>
                <sch:let name="eds" value="$edsDoc//tei:text/tei:body/tei:listPerson/tei:person/@xml:id"/>
                <sch:let name="refValues" value="for $i in $eds return concat('http://syriaca.org/documentation/editors.xml#', $i)"/>
                <sch:assert test="
                  every $i in .
                  satisfies $i = $refValues">
                  Acceptable values for this @ref attribute include: 
                  <sch:value-of select="string-join($refValues, ' | ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          
          <remarks>
            <p>This customization limits the vaules of @ref attributes on <gi>name</gi> as child of <gi>titleStmt</gi> 
            to a Syriaca.org URI for project contributors.</p>
          </remarks>
        </elementSpec>
        
               
        <elementSpec ident="funder" module="header" mode="change">
          <content>
            <textNode/>
          </content>
          
          <remarks>
            <p> Within the <gi>titleStmt</gi>, funding bodies are identified with the
              <gi>funder</gi> element. If multiple funding bodies are relevant, then each one receives
              a separate <gi>funder</gi> element. </p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="editionStmt" module="header" mode="change">
          <content>
            <elementRef key="edition" minOccurs="1" maxOccurs="1"/>
          </content>
          
          <remarks>
            <p> The <gi>editionStmt</gi> allows the specification of an edition or version number.
              When a TEI file is first published online, that edition should be "1.0". Subsequent
              revisions may bump the revision number, either by a whole new version (i.e. to "2.0")
              or by a minor version (i.e. to "1.1"). </p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="publicationStmt" module="header" mode="change">
          <content>
            <sequence preserveOrder="true">
              <elementRef key="authority" minOccurs="1"/>
              <elementRef key="idno" minOccurs="1"/>
              <elementRef key="availability" minOccurs="1"/>
              <elementRef key="date" minOccurs="1"/>
            </sequence>
          </content>
          
          <remarks>
            <p>The <gi>publicationStmt</gi> is where we identify Syriaca.org as the entity responsible for publishing this information, 
              indicate the date of the most recent edit, and identify the use license (Creative Commons CC-BY).</p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="authority" module="header" mode="change">
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="authorityText" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:publicationStmt/tei:authority">
                <sch:assert test="normalize-space(.) = 'Syriaca.org: The Syriac Reference Portal'">
                  The &lt;authority&gt; element should contain the text: "Syriaca.org: The Syriac Reference Portal."
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          
          <remarks>
            <p>Syriaca.org is identified as the responsible entity using <gi>authority</gi>.</p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="licence" module="header" mode="change">
          <content>
            <elementRef key="p" minOccurs="1" maxOccurs="1"/>
          </content>
          <constraintSpec ident="licence" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:licence/tei:p">
                <sch:assert test="normalize-space(.) = 'Distributed under a Creative Commons Attribution 3.0 Unported License.'">
                  The &lt;licence&gt; element must contain &lt;p&gt; with the text: "Distributed under a Creative Commons Attribution 3.0 Unported License."
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          
          <remarks>
            <p> The <gi>license</gi> element, child of <gi>availability</gi>, is used to specify the Creative Commons CC-BY license under which 
              this record is made available. Some records may incorporate information from works under copyright (with permission), a fact which is also 
              indicated with <gi>license</gi>. </p>
          </remarks>
        </elementSpec>
        
        
        <elementSpec ident="seriesStmt" module="header" mode="change">
          <!-- Consider supplementing this with the seriesStmt from the Gazetteer. -->
          <content>
            <sequence minOccurs="1" maxOccurs="unbounded">
              <elementRef key="title" minOccurs="1" maxOccurs="2"/>
              <elementRef key="editor" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="respStmt" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="idno" minOccurs="1" maxOccurs="1"/>
              <elementRef key="biblScope" minOccurs="0" maxOccurs="1"/>
            </sequence>  
          </content>
          <!-- Test the following constraintSpecs further. They don't seem to be working correctly. May need to move them close to parent elements. -->
          <constraintSpec ident="titleInSeriesStmt" scheme="schematron">
            <constraint>
              <sch:rule context="tei:seriesStmt[1]/tei:title[1]">
                <sch:assert test="@level='s'">
                  The &lt;title&gt; requires a @level attribute with a value of "s".
                </sch:assert>
                <sch:assert test=". = 'SPEAR: Syriac Persons, Events, and Relations'">
                  This &lt;title&gt; must be "SPEAR: Syriac Persons, Events, and Relations".
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[2]/tei:title[1]">
                <sch:assert test="@level='m'">
                  The &lt;title&gt; requires a @level attribute with a value of "m".
                </sch:assert>
                <sch:assert test="
                  . = 'The Chronicle of Edessa' or
                  . = 'The Letters of Severus of Antioch' or
                  . = 'The Lives of the Eastern Saints'
                  ">
                  This &lt;title&gt; must be one of the following: "The Chronicle of Edessa", "The Lives of the Eastern Saints",
                  or "The Letters of Severus of Antioch".
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[2]/tei:title[2]">
                <sch:assert test="@type='sub'">
                  This &lt;title&gt; requires a @type attribute with a value of "sub".
                </sch:assert>
                <sch:assert test=". = 'A SPEAR Prosopography'">
                  This &lt;title&gt; must be "A SPEAR Prosopography".
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="editorInSeriesStmt" scheme="schematron">
            <constraint>
              <sch:rule context="tei:seriesStmt/tei:editor">
                <sch:assert test="@role='general'">
                  This &lt;editor&gt; must have a @role attribute with a value of "general".
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:seriesStmt/tei:editor">
                <sch:report test="@role='creator'">
                  This &lt;editor&gt; cannot have a @role attribute with a value of "creator".
                </sch:report>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[1]/tei:editor">
                <sch:assert test="@ref='http://syriaca.org/documentation/editors.xml#dschwartz'">
                  This &lt;editor&gt; must have a @ref attribute with a value of "http://syriaca.org/documentation/editors.xml#dschwartz".
                </sch:assert>
                <sch:assert test=". = 'Daniel L. Schwartz'">
                  This &lt;editor&gt; must be "Daniel L. Schwartz".
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="uriInSeriesStmt" scheme="schematron">
            <constraint>
              <sch:rule context="tei:seriesStmt[1]/tei:idno">
                <sch:assert test=". = 'https://spear-prosop.org'">
                  This &lt;idno&gt; must be "https://spear-prosop.org".
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[2]/tei:idno[preceding-sibling::tei:title = 'The Lives of the Eastern Saints']">
                <sch:assert test=". = 'https://spear-prosop.org/lives-eastern-saints'">
                  This &lt;idno&gt; must be "https://spear-prosop.org/lives-eastern-saints".
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[2]/tei:idno[preceding-sibling::tei:title = 'The Letters of Severus of Antioch']">
                <sch:assert test=". = 'https://spear-prosop.org/letters-severus'">
                  This &lt;idno&gt; must be "https://spear-prosop.org/letters-severus".
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="biblScopeInSeriesStmt" scheme="schematron">
            <constraint>
              <sch:rule context="tei:seriesStmt[1]">
                <sch:report test="tei:biblScope">
                  This &lt;seriesStmt&gt; cannot contain a &lt;biblScope&gt;.
                </sch:report>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[2]">
                <sch:assert test="tei:biblScope">
                  This &lt;seriesStmt&gt; requires a &lt;biblScope&gt;.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[2]/tei:biblScope">
                <sch:assert test="@unit='volume'">
                  This &lt;biblScope&gt; element requires a a @unit
                  attribute having a value of "volume".
                </sch:assert>
                <sch:assert test="tei:title">
                  This &lt;biblScope&gt; element requires a child &lt;title&gt; element.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:seriesStmt[2]/tei:biblScope/tei:title">
                <sch:assert test="@level='s'">
                  This &lt;title&gt; element requires a @level attribute with a value of "s".
                </sch:assert>
                <sch:assert test=". = 'SPEAR: Syriac Persons, Events, and Relations'">
                  This &lt;title&gt; element must contain "SPEAR: Syriac Persons, Events, and Relations".
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          
          
          <!-- remarks needed -->
        </elementSpec>
        
        <elementSpec ident="sourceDesc" module="header" mode="change">
          <content>
            <sequence minOccurs="0" maxOccurs="unbounded">
              <elementRef key="listBibl" minOccurs="1" maxOccurs="1"/>
              <elementRef key="listRelation" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
          
          <!-- remarks needed -->
        </elementSpec>
        
        <elementSpec ident="encodingDesc" module="header" mode="change">
          <content>
            <sequence preserveOrder="true">
              <elementRef key="editorialDecl" minOccurs="1" maxOccurs="1"/>
              <elementRef key="classDecl" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="editorialDecl" module="header" mode="change">
          <content>
            <elementRef key="p" minOccurs="1" maxOccurs="1"/>
          </content>
        </elementSpec>
        
        <elementSpec ident="classDecl" module="header" mode="change">
          <content>
            <elementRef key="taxonomy" minOccurs="1" maxOccurs="1"/>
          </content>
          
        </elementSpec>
        
        <elementSpec ident="taxonomy" module="header" mode="change">
          <content>
            <elementRef key="category" minOccurs="1" maxOccurs="1"/>
          </content>
          
        </elementSpec>
        
        <elementSpec ident="category" module="header" mode="change">
          <content>
            <elementRef key="catDesc" minOccurs="1" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="xml:id" mode="change">
              <valList type="closed">
                <valItem ident="calculated"/>
              </valList>
            </attDef>
          </attList>
          
        </elementSpec>
        
        <elementSpec ident="catDesc" module="header" mode="change">
          <content>
            <textNode/>
          </content>
          
        </elementSpec>
        
        <elementSpec ident="revisionDesc" module="header" mode="change">
          <content>
            <elementRef key="change" minOccurs="0" maxOccurs="unbounded"/>
          </content>
          <attList>
            <attDef ident="status" mode="change">
              <valList type="closed">
                <valItem ident="draft"/>
                <valItem ident="published"/>
              </valList>
            </attDef>
          </attList>
          
        </elementSpec>
        
        <elementSpec ident="body" module="textstructure" mode="change">
          <content>
            <elementRef key="ab" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <remarks>
            <p>The body of a SPEAR file contains factoids, each of which appears in a separate <gi>ab</gi> element. 
              As such, <gi>ab</gi> is the only acceptable child element of <gi>body</gi>.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="listRelation" mode="change" module="namesdates">
          <content>
            <elementRef key="relation" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <remarks>
            <p>SPEAR has three basic types of factoid data that are encoded using <gi>listPerson</gi>, <gi>listEvent</gi>,
              and <gi>listRelation</gi> elements. The TEI Guidelines allow the first two to nest inside <gi>ab</gi> 
              while the last one is not. For uniformity and ease of encoding,
              SPEAR makes the <gi>listRelation</gi> element a part of the model class
              model.listLike so that it can function like other list elements and nest directly
              under the <gi>ab</gi> element. SPEAR also removes all attributes from the
              <gi>listRelation</gi> element and restricts the child elements to <gi>relation</gi>.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="bibl" module="core" mode="change">
          <content>
            <sequence minOccurs="0" maxOccurs="1" preserveOrder="true">
              <elementRef key="title" minOccurs="0" maxOccurs="2"/>
              <elementRef key="author" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="editor" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="pubPlace" minOccurs="0" maxOccurs="1"/>
              <elementRef key="publisher" minOccurs="0" maxOccurs="1"/>
              <elementRef key="date" minOccurs="0" maxOccurs="1"/>
              <elementRef key="biblScope" minOccurs="0" maxOccurs="2"/>
              <elementRef key="ptr" minOccurs="1" maxOccurs="1"/>
              <elementRef key="citedRange" minOccurs="0" maxOccurs="3"/>
            </sequence>
          </content>
          <constraintSpec ident="id-in-back-bibl" scheme="schematron">
            <constraint>
              <sch:rule context="tei:back//tei:bibl">
                <sch:assert test="@xml:id">A &lt;bibl&gt; element in the back matter must contain an
                  @xml:id attribute.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:back//tei:bibl/@xml:id">
                <sch:let name="docURIno"
                  value="//tei:publicationStmt/tei:idno[@type='URI']/substring-after(substring-before(., '/tei'), 'spear-prosop.org/')"/>
                <sch:assert test="contains(., concat('bibl', $docURIno, '-'))">The @xml:id on 
                  &lt;bibl&gt; in the back matter must take the following form: 'bibl' +
                    '<sch:value-of select="$docURIno"/>' + '-' + a unique number.</sch:assert>
                <sch:assert
                  test="count(distinct-values(//tei:back//tei:bibl/@xml:id)) eq count(//tei:back//tei:bibl/@xml:id)"
                  >Each @xml:id attribute on &lt;bibl&gt; must have a unique value.</sch:assert>
                <sch:report test="matches(substring-after(., '-'), '\D')">A properly formatted
                  @xml:id ends with a number.</sch:report>
                <sch:assert test="matches(substring-after(., '-'), '\d')">A properly formatted
                  @xml:id ends with a number.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <valList type="closed">
                <valItem ident="primary"/>
                <valItem ident="secondary"/>
                <valItem ident="urn"/>
              </valList>
            </attDef>
          </attList>
          
          
          
          <remarks>
            <p>SPEAR only uses @xml:id and @type attributes on the <gi>bibl</gi> element. SPEAR uses
              <gi>bibl</gi> elements with an @xml:id only in the <gi>back</gi> of the TEI file. The 
              @type attribute indicates whether the <gi>bibl</gi> is "primary", "secondary", or a "urn". 
            </p>
              <p>Since SPEAR relies on the Linked Open Data infrastructure of Syriaca.org, a <gi>bibl</gi>
              element in the body only requires a <gi>ptr</gi> element indicating the Syriaca.org URI or CTS URN for 
              the bibliographic reference. When indicating a CTS URNs no other additional information 
              is required. When indicating a Syriaca.org URI, a <gi>citedRange</gi> is needed.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="biblScope" module="core" mode="change">
          <content>
            <sequence minOccurs="0" maxOccurs="1">
              <textNode/>
              <elementRef key="title" minOccurs="0" maxOccurs="1"/>
              <elementRef key="idno" minOccurs="0" maxOccurs="1"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="unit" usage="req" mode="change">
              <valList type="closed">
                <valItem ident="pp">
                  <desc>the element contains a page number or page range.</desc>
                </valItem>
                <valItem ident="line">
                  <desc>the element contains a line number or line range.</desc>
                </valItem>
                <valItem ident="part">
                  <desc>the element contains a part of a book or collection, i.e. chapter and verse
                    of a biblical text.</desc>
                </valItem>
                <valItem ident="column">
                  <desc>the element identifies a column.</desc>
                </valItem>
                <valItem ident="volume"/>
              </valList>
            </attDef>
          </attList>
          
        </elementSpec>

        <elementSpec ident="citedRange" module="core" mode="replace">
          <content>
            <textNode/>
          </content>
          <attList>
            <attDef ident="unit" mode="add" usage="req">
              <datatype>
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="closed">
                <valItem ident="p">
                  <desc>the element contains a page number or page range.</desc>
                </valItem>
                <valItem ident="line">
                  <desc>the element contains a line number or line range.</desc>
                </valItem>
                <valItem ident="part">
                  <desc>the element contains a part of a book or collection, i.e. chapter and verse
                    of a biblical text.</desc>
                </valItem>
                <valItem ident="column">
                  <desc>the element identifies a column.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          
          <remarks>
            <p>SPEAR only allows text in a <gi>citedRange</gi> element and requires the use of a @unit attribute with a closed list.
              SPEAR prefers that encoders use the part value and cite ancient texts according to
              section numbers.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="choice" module="core" mode="change">
          <classes mode="replace">
            <memberOf key="model.linePart"/>
            <memberOf key="model.pPart.editorial"/>
          </classes>
          
          
        </elementSpec>

        <elementSpec ident="date" module="core" mode="change">
          <!-- I need a rule stating that when the date element does not have a choice ancestor it must have calendar="Gregorian"-->
          <classes mode="replace">
            <memberOf key="model.dateLike"/>
            <memberOf key="model.publicationStmtPart.detail"/>
            <memberOf key="att.datable.custom"/>
            <memberOf key="att.datable.w3c"/>
          </classes>
          <attList>
            <attDef ident="datingMethod" mode="change" usage="opt">
              <datatype>
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valList type="semi">
                <valItem ident="Seleucid">
                  <desc>the element contains a date (year) according to the Seleucid
                    calendar.</desc>
                </valItem>
                <valItem ident="Seleucid-SyriacMonths">
                  <desc>the element contains a date (month and year) according to the Seleucid
                    calendar.</desc>
                </valItem>
                <valItem ident="regnalYear">
                  <desc>the element contains a date according to the year of a king's reign.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="calendar" mode="add" usage="opt">
              <datatype>
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="Gregorian-in-reg-date" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:date[parent::tei:reg]/@calendar">
                    <sch:assert test=". = 'Gregorian'">A &lt;date&gt; element child of &lt;reg&gt;
                      must have a @calendar attribute with a value of "Gregorian".</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
              <valList type="semi">
                <valItem ident="Gregorian">
                  <desc>The element contains a date according to the Gregorian calendar.</desc>
                </valItem>
                <valItem ident="Seleucid">
                  <desc>The element contains a date according to the Seleucid calendar.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          
          
          
          
          <remarks>
            <p></p>
            <!-- I need to deal with an inconsistency in my encoding. Calendar and datingMethod currently offer two different ways to refer to something like the Seleucid Calendar. -->
          </remarks>
        </elementSpec>

        <elementSpec ident="desc" module="core" mode="replace">
          <content>
            <sequence minOccurs="0" maxOccurs="unbounded" preserveOrder="false">
              <textNode/>
              <elementRef key="choice" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="date" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="persName" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="orgName" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="rs" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="bibl" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="listRelation" minOccurs="0" maxOccurs="1"/>
              <elementRef key="title" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <constraintSpec ident="descContent" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:ab//tei:desc">
                <sch:report test="not(*) and string-length(normalize-space(.)) eq 0">Element of type
                  &lt;desc&gt; cannot be empty.</sch:report>
              </sch:rule>
              <sch:rule context="tei:ab/tei:listEvent/tei:event/tei:desc" role="warning">
                <sch:assert test="./tei:persName or tei:placeName">The &lt;desc&gt; element should
                  generally contain either &lt;persName&gt; or &lt;placeName&gt;. SPEAR
                  encourages a liberal use of &lt;persName&gt;, &lt;placeName&gt;, and &lt;date&gt;
                  elements in the &lt;desc&gt; element of event factoids.</sch:assert>
              </sch:rule>
              
            </constraint>
          </constraintSpec>
          <constraintSpec ident="descInRelation" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:body/tei:ab/tei:listRelation/tei:relation">
                <sch:assert test="tei:desc">
                  This &lt;relation&gt; requires a &lt;desc&gt;.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:sourceDesc//tei:relation">
                <sch:report test="tei:desc">
                  The &lt;desc&gt; element may not appear here.
                </sch:report>
              </sch:rule>
              <sch:rule context="//tei:ab/tei:listEvent/tei:listRelation/tei:relation/tei:desc">
                <sch:let name="SameEventURIs" value="tokenize(parent::tei:relation/@mutual, ' ')"/>
                <sch:assert test="count(child::tei:rs) = count($SameEventURIs)">
                  This &lt;desc&gt; must contain <sch:value-of select="count($SameEventURIs)"/> &lt;rs&gt; elements, one for each values in the @mutual attribute on &lt;relation&gt;.
                </sch:assert>
                <sch:assert test="count(distinct-values(tei:rs/@ref)) = count(tei:rs)">
                  This &lt;desc&gt; requires &lt;rs&gt; elements with unique @ref attribute values. 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:ab/tei:listEvent/tei:listRelation/tei:relation[@ref='syriaca:SameEvent']/tei:desc">
                <sch:let name="SameEventURIs" value="tokenize(parent::tei:relation/@mutual, ' ')"/>
                <sch:assert test="starts-with(normalize-space(.), 'The following factoids deal with the same event: ')">
                  This &lt;desc&gt; must begin with "The following factoids deal with the same event: " 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:ab/tei:listEvent/tei:listRelation/tei:relation[@ref='syriaca:ProxmiateEvent']/tei:desc">
                <sch:let name="SameEventURIs" value="tokenize(parent::tei:relation/@mutual, ' ')"/>
                <sch:assert test="starts-with(normalize-space(.), 'The following factoids deal with closely related events: ')">
                  This &lt;desc&gt; must begin with "The following factoids deal with related events: " 
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>This customization does not allow attributes on the <gi>desc</gi> element. It also
              restricts child elements to <gi>choice</gi>, <gi>date</gi>, <gi>persName</gi>, and
              <gi>placeName</gi>.</p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="title" module="core" mode="change">
          <constraintSpec ident="ref-value" scheme="schematron">
            <constraint>
              <sch:rule context="tei:title/@ref">
                <sch:assert test="matches(., concat('http://syriaca.org/work/', '\d+'))">
                  The @ref attribute must take a Syriaca.org work URI
                  which reqires the form 'http://syriaca.org/work/{\d+}' 
                  (where {\d+} is a number).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="rs" module="core" mode="change">
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="rsInRelationDesc" scheme="schematron">
            <!-- I need to rewrite a rule that will do this this @active, @passive, and @mutual in ab/listRelation. -->
            <constraint>
              <sch:rule context="//tei:ab/tei:listEvent/tei:listRelation/tei:relation/tei:desc/tei:rs/@ref">
                <sch:let name="SameEventURIs" value="tokenize(ancestor::tei:relation/@mutual, ' ')"/>
                <sch:let name="countMutual" value="for $i in $SameEventURIs return count($i)"/>
                <sch:assert test=". = $SameEventURIs">
                  Acceptable values: <sch:value-of select="string-join($SameEventURIs, '; ')"/>
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:ab//tei:rs">
                <sch:let name="URIno" value="substring-after(@ref, 'spear-prosop.org/')"/>
                <sch:assert test=". = $URIno">
                  The text node of this &lt;rs&gt; element must be <sch:value-of select="$URIno"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>

        <elementSpec ident="editor" module="core" mode="change">
          <classes mode="replace">
            <memberOf key="model.respLike"/>
          </classes>
          <constraintSpec ident="editorInTitleStmt" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:titleStmt/tei:editor">
                <sch:assert test="@role">
                  This &lt;editor&gt; must have a @role attribute.
                </sch:assert>
                <sch:assert test="@ref">
                  This &lt;editor&gt; must have a @ref attribute.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:titleStmt//tei:editor/@ref">
                <sch:let name="edsDoc"
                  value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/editors.xml')"/>
                <sch:let name="eds" value="$edsDoc//tei:text/tei:body/tei:listPerson/tei:person/@xml:id"/>
                <sch:let name="refValues" value="for $i in $eds return concat('http://syriaca.org/documentation/editors.xml#', $i)"/>
                <sch:assert test="
                  every $i in .
                  satisfies $i = $refValues">
                  Acceptable values for this @ref attribute include: 
                  <sch:value-of select="string-join($refValues, ' | ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="role" mode="add" usage="opt">
              <datatype>
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="semi">
                <valItem ident="creator">
                  <desc>A person involved in the creation of this xml file</desc>
                </valItem>
                <valItem ident="general">
                  <desc>A person responsible for this xml file or collection of xml files</desc>
                </valItem>
                <valItem ident="translator"/>
              </valList>
            </attDef>
            <attDef ident="ref" mode="add" usage="opt">
              <datatype minOccurs="1">
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>This customization limits the attributes available on <gi>desc</gi> to
              @role and @ref and suggests values for @role.</p>
          </remarks>
        </elementSpec>

        

        <elementSpec ident="corr" module="core" mode="change">
          <classes mode="replace">
            <memberOf key="model.choicePart"/>
            <memberOf key="model.pPart.transcriptional"/>
          </classes>
          
          
        </elementSpec>

        <elementSpec ident="listEvent" module="namesdates" mode="replace">
          <content>
            <elementRef key="event" minOccurs="1" maxOccurs="1"/>
          </content>
        </elementSpec>

        <elementSpec ident="listPerson" module="namesdates" mode="replace">
          <content>
            <alternate>
              <elementRef key="person" minOccurs="1" maxOccurs="1"/>
              <elementRef key="personGrp" minOccurs="1" maxOccurs="1"/>
            </alternate>
          </content>
          
        </elementSpec>

        <elementSpec ident="orig" module="core" mode="change">
          <classes mode="replace">
            <memberOf key="model.choicePart"/>
            <memberOf key="model.pPart.transcriptional"/>
          </classes>
          
        </elementSpec>

        <elementSpec ident="personGrp" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="model.personLike"/>
          </classes>
          <content>
            <alternate>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="ptr" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="education" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="nationality" minOccurs="0" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="residence" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="occupation" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="langKnowledge" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="state" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="trait" minOccurs="0" maxOccurs="1"/>
              </sequence>
              <sequence>
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="socecStatus" minOccurs="0" maxOccurs="1"/>
              </sequence>
            </alternate>
          </content>
          <attList>
            <attDef ident="role" mode="delete"/>
            <attDef ident="age" mode="delete"/>
            <attDef ident="size" mode="delete"/>
          </attList>
          
        </elementSpec>

        <elementSpec ident="reg" module="core" mode="change">
          <classes mode="replace">
            <memberOf key="model.choicePart"/>
            <memberOf key="model.pPart.transcriptional"/>
          </classes>
          
        </elementSpec>

        <elementSpec ident="sic" module="core" mode="change">
          <classes mode="replace">
            <memberOf key="model.choicePart"/>
            <memberOf key="model.pPart.transcriptional"/>
          </classes>
          
        </elementSpec>

        <elementSpec ident="ab" module="linking" mode="replace">
          <content>
            <alternate>
              <sequence preserveOrder="true">
                <elementRef key="idno" minOccurs="1" maxOccurs="1"/>
                <elementRef key="listPerson" minOccurs="1" maxOccurs="1"/>
                <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
                <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>

              <sequence preserveOrder="true">
                <elementRef key="idno" minOccurs="1" maxOccurs="1"/>
                <elementRef key="listEvent" minOccurs="1" maxOccurs="1"/>
                <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
                <elementRef key="listRelation" minOccurs="0" maxOccurs="1"/>
                <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>

              <sequence preserveOrder="true">
                <elementRef key="idno" minOccurs="1" maxOccurs="1"/>
                <elementRef key="listRelation" minOccurs="1" maxOccurs="1"/>
                <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
                <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
            </alternate>
          </content>
          <constraintSpec ident="atts-on-ab" scheme="schematron">
            <constraint>
              <sch:rule context="tei:ab[ancestor::tei:body]">
                <sch:assert test="@xml:id">An &lt;ab&gt; descendant of &lt;body&gt; requires an @xml:id attribute.</sch:assert>
                <sch:assert test="@resp">An &lt;ab&gt; descendant of &lt;body&gt; requires a @resp attribute.</sch:assert>
                <sch:assert test="@type='factoid'">An &lt;ab&gt; descendant of &lt;body&gt; requires a @type attribute with the value "factoid".</sch:assert>
              </sch:rule>
              <sch:rule context="tei:ab[ancestor::tei:body]/@resp">
                <sch:let name="contributorRefs" value="//tei:name[ancestor::tei:respStmt]/@ref"/>
                <sch:let name="respPtrs" value="for $i in $contributorRefs return substring-after($i, '.xml')"/>
                <sch:assert test="
                  every $i in (tokenize(., ' '))
                  satisfies $i = $respPtrs">
                  Acceptable values for this @resp attribute include: 
                  <sch:value-of select="string-join($respPtrs, '; ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" usage="req" mode="add">
              <datatype>
                <dataRef name="ID"/>
              </datatype>
              <constraintSpec ident="ab-ids" scheme="schematron">
                <constraint>
                  <sch:assert test="starts-with(., 'factoid-')">An @xml:id attribute
                    starts with 'factoid-'.</sch:assert>
                  <sch:report test="matches(substring-after(., '-'), '\D')">A properly formatted
                    SPEAR factoid URI ends with a hyphen followed by a number.</sch:report>
                  <sch:assert test="matches(substring-after(., '-'), '\d')">A properly formatted
                    SPEAR factoid URI ends with a number.</sch:assert>
                  <!--<sch:assert test="count(distinct-values(//tei:ab/@xml:id)) eq count(//tei:ab/@xml:id)"
                    >Each &lt;ab&gt; element @uri attribute must end with a unique number following
                    the "-".</sch:assert>-->
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="resp" usage="req" mode="add">
              <!-- Take rule from place ODD that will require values to validate against the list. -->
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
            <attDef ident="type" usage="req">
              <datatype>
                <dataRef key="teidata.enumerated"/>
              </datatype>
            </attDef>
            <attDef ident="subtype" mode="add" usage="req">
              <valList type="closed">
                <valItem ident="birth">
                  <gloss>birth</gloss>
                  <desc>Used to designate person factoids that encode birth dates and/or locations</desc>
                </valItem>
                <valItem ident="citizenship">
                  <gloss>citizenship</gloss>
                  <desc>Used to designate person factoids that encode citizenship</desc>
                </valItem>
                <valItem ident="death">
                  <gloss>death</gloss>
                  <desc>Used to designate person factoids that encode death dates and/or locations</desc>
                </valItem>
                <valItem ident="education">
                  <gloss>education</gloss>
                  <desc>Used to designate person factoids that encode education</desc>
                </valItem>
                <valItem ident="ethnicLabel">
                  <gloss>ethnic label</gloss>
                  <desc>Used to designate person factoids that encode ethnic labels</desc>
                </valItem>
                <valItem ident="event">
                  <gloss>event</gloss>
                  <desc>Used to designate event factoids</desc>
                </valItem>
                <valItem ident="gender">
                  <gloss>gender</gloss>
                  <desc>Used to designate person factoids that encode gender</desc>
                </valItem>
                <valItem ident="langKnown">
                  <gloss>language known</gloss>
                  <desc>Used to designate person factoids that encode language knowledge</desc>
                </valItem>
                <valItem ident="mentalState">
                  <gloss>mental state</gloss>
                  <desc>Used to designate person factoids that encode mental states</desc>
                </valItem>
                <valItem ident="nameVariant">
                  <gloss>name variant</gloss>
                  <desc>Used to designate person factoids that encode name variants</desc>
                </valItem>
                <valItem ident="occupation">
                  <gloss>occupation</gloss>
                  <desc>Used to designate person factoids that encode occupations</desc>
                </valItem>
                <valItem ident="physicalTrait">
                  <gloss>physical trait</gloss>
                  <desc>Used to designate person factoids that encode physical traits</desc>
                </valItem>
                <valItem ident="relation">
                  <gloss>relation</gloss>
                  <desc>Used to designate relation factoids</desc>
                </valItem>
                <!--<valItem ident="religiousAffiliation">
                  <gloss>religious affiliation</gloss>
                  <desc>Used to designate person factoids that encode the religious affiliation of a person</desc>
                </valItem>-->
                <valItem ident="residence">
                  <gloss>residence</gloss>
                  <desc>Used to designate person factoids that encode places and dates of residence</desc>
                </valItem>
                <valItem ident="sanctity">
                  <gloss>sanctity</gloss>
                  <desc>Used to designate person factoids that encode sanctity</desc>
                </valItem>
                <valItem ident="socecStatus">
                  <gloss>socio-economic status</gloss>
                  <desc>Used to designate person factoids that encode socio-econimic status</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          
          <remarks>
            <p>
              This customization requires the basic pattern of SPEAR factoids to be encoded correctly. Each
              factoid is encoded in an <gi>ab</gi> element. Since each factoid contains data on a 
              Person, Event, or Relation, the schema requires that <gi>ab</gi> must contain a
              <gi>listPerson</gi>, <gi>listEvent</gi>, or <gi>listRelation</gi> child element. Since every
              factoid requires a bibliographic reference, every <gi>ab</gi> must contain one or more child
              <gi>bibl</gi> elements. The encoder also has the option of adding a <gi>note</gi>
              element to the factoid as well. </p>
            <p>This customization also requires that every <gi>ab</gi> element receives @xml:id, @type, @subtype, 
              and @resp attributes. The @xml:id must take the form "factoid-{\d}" where {\d} is a number unique within 
              the document. The @type attribute must be "factoid". The @subtype attribute comes from a closed list
              of data types encoded in the SPEAR project. The @resp attribute must point to an editor listed in the 
              <gi>titleStmt</gi>. This ensures that all contributions are attributed at the factoid level.</p>
          </remarks>
        </elementSpec>
        
        <elementSpec ident="idno" module="header" mode="change">
          <classes mode="replace">
            <memberOf key="model.publicationStmtPart.detail"/>
          </classes>
          <constraintSpec ident="type-on-idno" scheme="schematron">
            <constraint>
              <sch:rule context="tei:ab[ancestor::tei:body]/tei:idno">
                <sch:assert test="@type='URI'">An &lt;idno&gt; descendant of &lt;ab&gt;
                  requires a @type attribute with the value "URI".</sch:assert>
              </sch:rule>
              <sch:rule context="//tei:publicationStmt/tei:idno">
                <sch:assert test="@type='URI'">This &lt;idno&gt; 
                  requires a @type attribute with the value "URI".</sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt/tei:idno">
                <sch:assert test="@type='URI'">This &lt;idno&gt; element
                  requires a @type attribute with the value "URI".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="doc-idno-uri" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:publicationStmt/tei:idno[@type='URI']">
                <sch:let name="fileNo" value="replace(document-uri(/), '[\D]', '')"/>
                <sch:assert test=". = concat('https://spear-prosop.org/', $fileNo, '/tei')">
                  The text node of this &lt;idno&gt; must be "https://spear-prosop.org/<sch:value-of select="$fileNo"/>/tei".
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="factoidIDNO" scheme="schematron">
            <constraint>
              <sch:rule context="tei:ab[ancestor::tei:body]/tei:idno">
                <sch:let name="factoidNo" value="parent::tei:ab/@xml:id/substring-after(., 'factoid')"/>
                <sch:assert
                  test="contains(., concat(//tei:publicationStmt/tei:idno[@type]/substring-before(., '/tei'), $factoidNo))"
                  >This factoid URI must be: "<sch:value-of
                    select="concat(//tei:publicationStmt/tei:idno[@type]/substring-before(., '/tei'), $factoidNo)"
                  />.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type">
              <datatype>
                <dataRef key="teidata.enumerated"></dataRef>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>
              This customization requires properly formatted identifiers for each TEI document 
              and for each factoid. It ensures the alignment of the document cool-URI, the document name (always a number), 
              and the factoid cool-URI.</p>
            <p>In the <gi>teiHeader</gi>, an <gi>idno</gi> requires a @type attribute indicating that it is a "URI".
              It must also have the text node "https://spear-prosop.org/{\d}/tei", where {\d} is a number that matches
              the number of the document name.</p>
            <p>Each factoid also requires an <gi>idno</gi> with a @type attribute of "URI". 
              It must contain the full cool-URI for that factoid. This URI is constructed using the <gi>idno</gi> from the
              <gi>publicationStmt</gi> and attaching to it the "-{\d}" from the @xml:id on the parent <gi>ab</gi>.
              </p>
          </remarks>
          
          
        </elementSpec>

        <elementSpec ident="event" module="namesdates" mode="change">
          <content>
            <elementRef key="desc" minOccurs="1" maxOccurs="1"/>
          </content>
          <constraintSpec ident="ana-on-event" scheme="schematron">
            <constraint>
              <sch:rule context="tei:event/@ana">
                <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                <sch:let name="taxonomyAllURIs" value="$ti//listURI[@type = 'taxonomyAllURIs']/uri"/>
                <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $taxonomyAllURIs)]"/>
                <sch:assert test="every $i in $anaTokens satisfies $i = $taxonomyAllURIs" role="warning">
                  <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. Please ensure that an appropriate URI does 
                  not appear in the Taxonomy before proceeding. If you find no appropriate concept in the Taxonomy, please choose a keyword of your own for the editors to consider.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="dates-on-event" scheme="schematron">
            <constraint>
              <sch:rule context="tei:event[tei:desc/tei:date/@when] | tei:event[tei:desc/tei:choice/tei:corr/tei:date/@when] | tei:event[tei:desc/tei:choice/tei:reg/tei:date/@when]">
                <sch:assert test="./@when = ./tei:desc/tei:date/@when | ./tei:desc/tei:choice/tei:corr/tei:date/@when | ./tei:desc/tei:choice/tei:reg/tei:date/@when">
                  This &lt;event&gt; must have a @when attribute with the value <sch:value-of select="./tei:desc/tei:date/@when | ./tei:desc/tei:choice/tei:corr/tei:date/@when | ./tei:desc/tei:choice/tei:reg/tei:date/@when"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[tei:desc/tei:date/@notBefore] | tei:event[tei:desc/tei:choice/tei:corr/tei:date/@notBefore] | tei:event[tei:desc/tei:choice/tei:reg/tei:date/@notBefore]">
                <sch:assert test="./@notBefore = ./tei:desc/tei:date/@notBefore | ./tei:desc/tei:choice/tei:corr/tei:date/@notBefore | ./tei:desc/tei:choice/tei:reg/tei:date/@notBefore">
                  This &lt;event&gt; must have a @notBefore attribute with the value <sch:value-of select="./tei:desc/tei:date/@notBefore | ./tei:desc/tei:choice/tei:corr/tei:date/@notBefore | ./tei:desc/tei:choice/tei:reg/tei:date/@notBefore"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[tei:desc/tei:date/@notAfter] | tei:event[tei:desc/tei:choice/tei:corr/tei:date/@notAfter] | tei:event[tei:desc/tei:choice/tei:reg/tei:date/@notAfter]">
                <sch:assert test="./@notAfter = ./tei:desc/tei:date/@notAfter | ./tei:desc/tei:choice/tei:corr/tei:date/@notAfter | ./tei:desc/tei:choice/tei:reg/tei:date/@notAfter">
                  This &lt;event&gt; must have a @notAfter attribute with the value <sch:value-of select="./tei:desc/tei:date/@notAfter | ./tei:desc/tei:choice/tei:corr/tei:date/@notAfter | ./tei:desc/tei:choice/tei:reg/tei:date/@notAfter"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[tei:desc/tei:date/@from] | tei:event[tei:desc/tei:choice/tei:corr/tei:date/@from] | tei:event[tei:desc/tei:choice/tei:reg/tei:date/@from]">
                <sch:assert test="./@from = ./tei:desc/tei:date/@from | ./tei:desc/tei:choice/tei:corr/tei:date/@from | ./tei:desc/tei:choice/tei:reg/tei:date/@from">
                  This &lt;event&gt; must have a @from attribute with the value <sch:value-of select="./tei:desc/tei:date/@from | ./tei:desc/tei:choice/tei:corr/tei:date/@from | ./tei:desc/tei:choice/tei:reg/tei:date/@from"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[tei:desc/tei:date/@to] | tei:event[tei:desc/tei:choice/tei:corr/tei:date/@to] | tei:event[tei:desc/tei:choice/tei:reg/tei:date/@to]">
                <sch:assert test="./@to = ./tei:desc/tei:date/@to | ./tei:desc/tei:choice/tei:corr/tei:date/@to | ./tei:desc/tei:choice/tei:reg/tei:date/@to">
                  This &lt;event&gt; must have a @to attribute with the value <sch:value-of select="./tei:desc/tei:date/@to | ./tei:desc/tei:choice/tei:corr/tei:date/@to | ./tei:desc/tei:choice/tei:reg/tei:date/@to"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="relation-in-event" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:ab//tei:event/tei:desc/tei:listRelation/tei:relation">
                <sch:report test="tei:desc">A &lt;relation&gt; element inside of an &lt;event&gt; element cannot take a &lt;desc&gt; element.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>
              This customization makes <gi>desc</gi> the only acceptable child of <gi>event</gi>. It also requires an @ana attribute
              and constrains the values of that attribute to the full list of Syriaca.org keyword URIs. In the case of dates associated with an event,
              the customization also requires that date attributes (@when, @notBefore, @notAfter, @from, and @to) match on the <gi>event</gi> element and within the child
              <gi>desc</gi> element.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="note" module="core" mode="change">
          <constraintSpec ident="note-children-in-context" scheme="schematron">
            <constraint>
              <sch:rule context="tei:note[parent::tei:birth and preceding-sibling::tei:placeName]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a birth place factoid
                  must contain a &lt;persName&gt;.</sch:assert>
                <sch:assert test="tei:placeName">The &lt;note&gt; element in a birth place factoid
                  must contain a &lt;placeName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:birth and preceding-sibling::tei:date]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a birth date factoid
                  must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule
                context="tei:note[parent::tei:nationality and preceding-sibling::tei:placeName]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a citizenship factoid
                  must contain a &lt;persName&gt;.</sch:assert>
                <sch:assert test="tei:placeName">The &lt;note&gt; element in a citizenship factoid
                  must contain a &lt;placeName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:death and preceding-sibling::tei:placeName]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a death place factoid
                  must contain a &lt;persName&gt;.</sch:assert>
                <sch:assert test="tei:placeName">The &lt;note&gt; element in a birth place factoid
                  must contain a &lt;placeName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:education]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in an education factoid
                  must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:death and preceding-sibling::tei:date]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a death date factoid
                  must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:occupation]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in an occupation factoid
                  must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule
                context="tei:note[parent::tei:residence and preceding-sibling::tei:placeName]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a residence factoid must
                  contain a &lt;persName&gt;.</sch:assert>
                <sch:assert test="tei:placeName">The &lt;note&gt; element in a residence factoid
                  must contain a &lt;placeName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:socecStatus]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a socioeconomic status
                  factoid must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule
                context="tei:note[parent::tei:langKnowledge and preceding-sibling::tei:langKnown]">
                <sch:assert test="tei:persName">The &lt;note&gt; element in a language-known factoid
                  must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:trait]">
                <sch:assert test="tei:persName">The &lt;note&gt; element inside the &lt;trait&gt;
                  element must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:state]">
                <sch:assert test="tei:persName">The &lt;note&gt; element inside the &lt;state&gt;
                  element must contain a &lt;persName&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:reg and preceding-sibling::tei:date]">
                <sch:assert test="@ana">This &lt;note&gt; element requires an @ana
                  attribute.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="names-in-notes" scheme="schematron">
            <constraint>
              <sch:rule context="tei:note[parent::tei:birth | parent::tei:death | parent::tei:education | parent::tei:langKnowledge | parent::tei:nationality | parent::tei:occupation | parent::tei:residence | parent::tei:socecStatus | parent::tei:state | parent::tei:trait]/tei:persName[1]/@ref">
                <sch:assert test=". = ancestor::tei:person/tei:persName/@ref | ancestor::tei:personGrp/tei:persName/@ref">
                  The URI in this @ref attribute and the URI in the @ref attribute on the &lt;persName&gt; that
                  is the child of &lt;person&gt; must match.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:note[parent::tei:birth | parent::tei:death | parent::tei:nationality | parent::tei:residence]/tei:placeName[1]/@ref">
                <sch:report test=". = ancestor::tei:person/tei:placeName/@ref | ancestor::tei:personGrp/tei:placeName/@ref">
                  The URI in this @ref attribute and the URI in the @ref attribute on the &lt;placeName&gt; that
                  is the child of &lt;person&gt; must match.
                </sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="date-note-content" scheme="schematron">
            <constraint>
              <sch:rule context="tei:note[parent::tei:reg and preceding-sibling::tei:date]">
                <sch:assert
                  test="normalize-space(.) = 'This regularized date was calculated by the SPEAR editor from a non-calendrical dating system such as regnal years, etc.'"
                  > The only note allowed in this context must contain the following text: "This
                  regularized date was calculated by the SPEAR editor from a non-calendrical dating
                  system such as regnal years, etc." </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="anchored" mode="delete"/>
            <attDef ident="targetEnd" mode="delete"/>
            <attDef ident="type" usage="opt" mode="replace">
              <datatype>
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <constraintSpec ident="notes-type-desc" scheme="schematron">
                <constraint>
                  <sch:rule
                    context="tei:note[parent::tei:birth or parent::tei:death or parent::tei:education or parent::tei:langKnowledge or parent::tei:nationality or parent::tei:occupation or parent::tei:residence or parent::tei:socecStatus or parent::tei:state or parent::tei:trait]">
                    <sch:assert test="@type = 'desc'">This &lt;note&gt; must contain the
                      attribute @type="desc" and other &lt;note&gt; types are not allowed in this context.
                      Other types of notes (those dealing with "certainty") may appear as children of
                      the &lt;ab&gt; element as needed.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
              <constraintSpec ident="dates-in-notes" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:note[parent::tei:education | parent::tei:langKnowledge | parent::tei:nationality | parent::tei:occupation | parent::tei:residence | parent::tei:socecStatus | parent::tei:state | parent::tei:trait]">
                    <sch:report test="./tei:date">
                      If you wish to apply a date to this factoid, you must use
                      date attributes (@when, @notBefore, @notAfter, @to, and/or @from) on the 
                      parent of the &lt;note&gt; element.
                    </sch:report>
                  </sch:rule>
                </constraint>
              </constraintSpec>
              <valList type="closed">
                <valItem ident="desc"/>
                <valItem ident="certainty"/>
                <valItem ident="relatedEvent"/>
              </valList>
            </attDef>
            <attDef ident="subtype" usage="opt" mode="replace">
              <datatype>
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <constraintSpec ident="certainty-subtype" scheme="schematron">
                <constraint>
                  <sch:rule context="//tei:note[@type='certainty']">
                    <sch:assert test="@subtype">
                      A &lt;note&gt; element with @type="certainty" requires a @subtype.
                    </sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
              <valList type="closed">
                <valItem ident="incerta"/>
                <valItem ident="dubia"/>
                <valItem ident="errata"/>
              </valList>
            </attDef>
            <attDef ident="ana" usage="opt" mode="replace">
              <datatype>
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valList type="closed">
                <valItem ident="#calculated"/>
              </valList>
            </attDef>
          </attList>
          <remarks>
            <p>
              SPEAR factoids contain <gi>note</gi> elements that allow the encoder to offer a more prose-oriented description of the data that they have
              derived from the source they are analyzing. The content of the <gi>note</gi> is what human users encounter when using the HTML serialization of 
              the data. This customization constrains the use of this element to ensure that the data
              marked up inside the <gi>note</gi> agrees with the more data-oriented encoding found elsewhere in the factoid.</p>
          </remarks>
          
        </elementSpec>

        <elementSpec ident="persName" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="att.datable.w3c"/>
            <memberOf key="model.nameLike.agent"/>
            <memberOf key="model.persStateLike"/>
          </classes>
          <attList>
            <attDef ident="ref" mode="add" usage="req">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ref-on-persName" scheme="schematron">
                <constraint>
                  <sch:rule context="//tei:text//tei:persName/@ref">
                    <sch:let name="personIndex" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/persons.xml')"></sch:let>
                    <sch:let name="personURIs" value="$personIndex//tei:person/@ref"/>
                    <sch:let name="error" value="."/>
                    <sch:report test="contains(., ' ')" role="error">This @ref may contain only one URI.</sch:report>
                    <sch:assert test="matches(., concat('http://syriaca.org/person/', '\d+'))" role="error">
                      The @ref attribute must take a Syriaca.org person URI which reqires 
                      the form 'http://syriaca.org/person/{\d+}' (where {\d+} is a number).
                    </sch:assert>
                    <sch:assert test="
                      every $i in .
                      satisfies $i = $personURIs" role="warning">
                      <sch:value-of select="$error"/> is not currently in use. 
                      Note that all person URIs take the form 'http://syriaca.org/person/{\d+}' 
                      (where {\d+} is a number). If a URI is not current available, replace the number portion of the URI with 
                      "#" followed without a space by a number that you use consistently when encoding information 
                      about that person. 
                    </sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>
              This customization requires <gi>persName</gi> to have a @ref attribute that points to a Syriaca.org authority file for a person.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="placeName" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="model.placeNamePart"/>
          </classes>
          <attList>
            <attDef ident="ref" usage="req">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ref-on-placeName" scheme="schematron">
                <constraint>
                  <sch:rule context="//tei:text//tei:placeName/@ref">
                    <sch:let name="placeIndex" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/places.xml')"/>
                    <sch:let name="placeURIs" value="$placeIndex//tei:place/@ref"/>
                    <sch:let name="error" value="."/>
                    <sch:report test="contains(., ' ')" role="error">This @ref may contain only one URI.</sch:report>
                    <sch:assert test="matches(., concat('http://syriaca.org/place/', '\d+'))" role="error">
                      The @ref attribute must take a Syriaca.org place URI which reqires 
                      the form 'http://syriaca.org/place/{\d+}' (where {\d+} is a number).
                    </sch:assert>
                    <sch:assert test="
                      every $i in .
                      satisfies $i = $placeURIs" role="warning">
                      <sch:value-of select="$error"/> is not currently in use. 
                      Note that all properly formatted place URIs take the form 'http://syriaca.org/place/{\d+}' 
                      (where {\d+} is a number). If a URI is not current available, replace the number portion of the URI with 
                      "#" followed without a space by a number that you use consistently when encoding information 
                      referring to that place. 
                    </sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>
              This customization requires <gi>placeName</gi> to have a @ref attribute that points to a Syriaca.org authority file for a place.</p>
          </remarks>
          
          
        </elementSpec>

        <elementSpec ident="ptr" module="core" mode="change">
          <classes mode="replace">
            <memberOf key="model.ptrLike"/>
          </classes>
          <attList>
            <attDef ident="target" usage="req">
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ptr-targets-in-context" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:sourceDesc//tei:bibl[@type = 'primary']/tei:ptr/@target">
                    <sch:let name="docURIno"
                      value="//tei:publicationStmt/tei:idno[@type]/substring-after(substring-before(., '/tei'), 'spear-prosop.org/')"/>
                    <sch:assert
                      test=". = concat('http://syriaca.org/work/', $docURIno) or starts-with(., 'http://syriaca.org/bibl/')"
                      > The @target attribute on a &lt;ptr&gt; element inside a &lt;bibl&gt; element
                      with @type="primary" takes limited values. It either must be
                        "http://syriaca.org/work/<sch:value-of select="$docURIno"/>" or
                      "http://syriaca.org/bibl/" followed by the corresponding Syriaca.org bibl URI
                      number. </sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:sourceDesc//tei:bibl[@type = 'urn']/tei:ptr/@target">
                    <sch:let name="docURIno"
                      value="//tei:publicationStmt/tei:idno[@type]/substring-after(substring-before(., '/tei'), 'spear-prosop.org/')"/>
                    <sch:assert
                      test="starts-with(., concat('urn:cts:syriacLit:nhsl', $docURIno, '.syriacCorpus'))"
                      > The @target attribute on a &lt;ptr&gt; element inside a &lt;bibl&gt; element
                      with @type="urn" must begin either with "urn:cts:syriacLit:nhsl<sch:value-of
                        select="$docURIno"/>.syriacCorpus" followed by the corresponding Syriac
                      Corpus URI number. </sch:assert>
                  </sch:rule>
                  <sch:rule context="//tei:body/tei:ab/tei:bibl[@type = 'urn']/tei:ptr/@target">
                    <sch:let name="urnBase"
                      value="//tei:sourceDesc//tei:bibl[@type = 'urn']/tei:ptr/@target"/>
                    <sch:assert test="starts-with(., concat($urnBase, ':'))">URN in a &lt;bibl&gt;
                      element inside a SPEAR factoid must begin with URN in the &lt;sourceDesc&gt;
                      element of the &lt;teiHeader&gt;: "<sch:value-of select="$urnBase"
                      />:".</sch:assert>
                  </sch:rule>
                  <sch:rule context="//tei:body//tei:bibl[@type = 'primary']/tei:ptr/@target">
                    <sch:assert
                      test=". = //tei:sourceDesc//tei:bibl[@type = 'primary']/tei:ptr/@target"> The
                      @target attribute on the &lt;ptr&gt; element, "<sch:value-of select="."/>," is
                      not among the valid options contained in the &lt;sourceDesc&gt; element of the
                      &lt;teiHeader&gt;: (<sch:value-of
                        select="string-join(//tei:sourceDesc//tei:bibl[@type = 'primary']/tei:ptr/@target, ';  ')"
                      />) </sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>
              This customization requires a <gi>ptr</gi> to have a @type attribute (indicating "primary", "secondary", or "URN") 
              and a @target attribute. It also ensures that the @target attribute with primary and secondary sources indicates a 
              Syriaca.org authority file for a work or a bibliographic item.
            </p>
          </remarks>
          
          
          
        </elementSpec>

        <elementSpec ident="relation" module="namesdates" mode="change">
          <content>
            <elementRef key="desc" minOccurs="0" maxOccurs="1"/>
          </content>
          <constraintSpec ident="ref-mutual-act-pass-in-relation" scheme="schematron">
            <constraint>
              <sch:rule context="tei:ab[@subtype='relation']/tei:listRelation/tei:relation | tei:ab[@subtype='event']/tei:listEvent/tei:event/tei:desc/tei:listRelation/tei:relation"><!-- This doesn't currently catch incorrect person URIs on @mutual, @active, and @passive when these are embedded in event factoids. -->
                <sch:let name="ti"
                  value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                <sch:let name="mutual"
                  value="$ti//listURI[@type = 'relationships']//uri[@ana = 'mutual']"/>
                <sch:let name="directed"
                  value="$ti//listURI[@type = 'relationships']//uri[@ana = 'directed']"/>
                <sch:assert test=".[@ref = $mutual]/@mutual or .[@ref = $directed]/@active"
                  >This &lt;relation&gt; takes either a @mutual attribute with mutual
                  relationships or both @active and @passive attributes with directed
                  relationships. Mutual relationships include: <sch:value-of
                    select="string-join($mutual, ';  ')"/>. Directed relationships include:
                    <sch:value-of select="string-join($directed, ';  ')"/>.</sch:assert>
                <sch:assert test=".[@ref = $mutual]/@mutual or .[@ref = $directed]/@passive"
                  >This &lt;relation&gt; takes either a @mutual attribute with mutual
                  relationships or both @active and @passive attributes with directed
                  relationships. Mutual relationships include: <sch:value-of
                    select="string-join($mutual, ';  ')"/>. Directed relationships include:
                    <sch:value-of select="string-join($directed, ';  ')"/>.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:ab[@subtype='event']/tei:listRelation/tei:relation">
                <sch:assert test="@mutual">A @mutual attribute is required on &lt;relation&gt;
                  in event factoids.</sch:assert>
                <sch:report test="@active">@active attributes are not allowed on &lt;relation&gt;
                  in event factoids.</sch:report>
                <sch:report test="@passive">@passive attributes are not allowed on &lt;relation&gt;
                  in event factoids.</sch:report>
              </sch:rule>
              <sch:rule context="tei:ab[@subtype='relation']/tei:listRelation/tei:relation/@mutual | tei:ab[@subtype='relation']/tei:listRelation/tei:relation/@active | tei:ab[@subtype='relation']/tei:listRelation/tei:relation/@passive | tei:ab[@subtype='event']/tei:listEvent/tei:event/tei:desc/tei:listRelation/tei:relation/@mutual | tei:ab[@subtype='event']/tei:listEvent/tei:event/tei:desc/tei:listRelation/tei:relation/@active | tei:ab[@subtype='event']/tei:listEvent/tei:event/tei:desc/tei:listRelation/tei:relation/@passive">
                <sch:let name="personIndex" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/persons.xml')"></sch:let>
                <sch:let name="personURIs" value="$personIndex//tei:person/@ref"/>
                <sch:let name="error" value="."/>
                <sch:assert test="
                  every $i in (tokenize(., ' '))
                  satisfies $i = $personURIs" role="warning">
                  <sch:value-of select="$error"/> is not currently in use. 
                  Note that all person URIs take the form 'http://syriaca.org/person/{\d+}' 
                  (where {\d+} is a number). If a URI is not current available, replace the number portion of the URI with 
                  "#" followed without a space by a number that you use consistently when encoding information 
                  about that person.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="dates-in-relations-in-events" scheme="schematron">
            <constraint>
              <sch:rule context="tei:event[@when]//tei:relation">
                <sch:assert test="./@when = ./ancestor::tei:event/@when">
                  This &lt;relation&gt; must have a @when attribute with the value <sch:value-of select="./ancestor::tei:event/@when"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[@notBefore]//tei:relation">
                <sch:assert test="./@notBefore = ./ancestor::tei:event/@notBefore">
                  This &lt;relation&gt; must have a @notBefore attribute with the value <sch:value-of select="./ancestor::tei:event/@notBefore"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[@notAfter]//tei:relation">
                <sch:assert test="./@notAfter = ./ancestor::tei:event/@notAfter">
                  This &lt;relation&gt; must have a @notAfter attribute with the value <sch:value-of select="./ancestor::tei:event/@notAfter"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[@from]//tei:relation">
                <sch:assert test="./@from = ./ancestor::tei:event/@from">
                  This &lt;relation&gt; must have a @from attribute with the value <sch:value-of select="./ancestor::tei:event/@from"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:event[@to]//tei:relation">
                <sch:assert test="./@to = ./ancestor::tei:event/@to">
                  This &lt;relation&gt; must have a @to attribute with the value <sch:value-of select="./ancestor::tei:event/@to"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attList>
              <attList org="choice">
                <attDef ident="active">
                  <datatype maxOccurs="unbounded">
                    <dataRef key="teidata.pointer"/>
                  </datatype>
                </attDef>
                <attDef ident="passive">
                  <datatype maxOccurs="unbounded">
                    <dataRef key="teidata.pointer"/>
                  </datatype>
                </attDef>
              </attList>
              <attDef ident="mutual">
                <datatype maxOccurs="unbounded">
                  <dataRef key="teidata.pointer"/>
                </datatype>
              </attDef>
            </attList>
            <attDef ident="ref" mode="change" usage="opt">
              <constraintSpec ident="ref-in-context" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:ab[@subtype='relation']/tei:listRelation/tei:relation/@ref">
                    <sch:let name="ti"
                      value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:assert
                      test=". = $ti//listURI[@type = 'relationships']//uri"
                      >Value must be one of the following from the Syriaca.org taxonomy:
                        <sch:value-of
                        select="string-join($ti//listURI[@type = 'relationships']//uri, ';  ')"
                      />.</sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:ab[@subtype='event']/tei:listRelation/tei:relation/@ref">
                    <sch:let name="ti"
                      value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:assert
                      test=". = $ti//listURI[@type = 'related-event']/uri"
                      >Value must be one of the following from the Syriaca.org taxonomy:
                        <sch:value-of
                        select="string-join($ti//listURI[@type = 'related-event']/uri, ';  ')"
                      />.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="name" mode="change" usage="opt">
              <constraintSpec ident="name-in-relation" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:sourceDesc/tei:listRelation/tei:relation/@name">
                    <sch:assert test=". = 'dcterms:isPartOf'">
                      This &lt;relation&gt; element must have a @name attribute with a value of "dcterms:isPartOf".
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:text//tei:relation">
                    <sch:report test="/@name">A @name attribute cannot appear here.</sch:report>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="type" mode="change" usage="req">
              <datatype maxOccurs="1">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <constraintSpec ident="type-on-relation" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:ab/tei:listEvent/tei:listRelation/tei:relation">
                    <sch:assert test="@type = 'event'">A &lt;relation&gt; element inside an event factoid
                      must take a @type attribute with the value "event".</sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:sourceDesc/tei:listRelation/tei:relation">
                    <sch:assert test="@type = 'part'">A @type attribute with the value
                      "part" is required.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
              <valList >
                <valItem ident="person">
                  <desc>Used to denote relationships involving persons</desc>
                </valItem>
                <valItem ident="event">
                  <desc>Used to denote relationships between event factoids</desc>
                </valItem>
                <valItem ident="part"/>
              </valList>
            </attDef>
            <attDef ident="ana" mode="change" usage="rec">
              <datatype minOccurs="0" maxOccurs="unbounded">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <constraintSpec ident="ana-on-event-relation" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:ab/tei:listRelation/tei:relation/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="qrURIs" value="$ti//listURI[@type = 'qualifier-relationship']//uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $qrURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $qrURIs">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($qrURIs, ';  ')"/>.</sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:ab/tei:listEvent/tei:listRelation/tei:relation">
                    <sch:report test="@ana">A &lt;relation&gt; element inside an event factoid cannot
                      have an @ana attribute.</sch:report>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>
              The <gi>relation</gi> element is used for personal relationships and constitutes one of the three main data types in SPEAR. 
              When SPEAR encodes straight relationships, they appear in a relationship factoid (tei:ab[@subtype="relation"]/tei:listRelation/tei:relation).
              Relationships can also appear inside an event factoid in cases where an event creates a relationship, i.e. a wedding is an event that
              created a spousal relationship. In such cases, SPEAR encodes this relationship inside the event factoid. In addition to these personal relationships,
              the <gi>relation</gi> element is also used to encode relationships between closely related events. The <gi>relation</gi> element is also used in 
              the <gi>teiHeader</gi>.
            </p>
            <p>
              In the context of personal relationships, this customization constrains the @ref, @ana, @active, @passive, and @mutual attributes.
              A @ref attribute is required and must contain a URI pointing to a personal relationship in the Syriac Taxonomy. An @ana attribute is optional but when 
              used must contain a URI pointing to a qualifier relationship in the Syriac Taxonomy, i.e. a sibling relationship might be qualified as a 
              step-sibling relationship using @ana. For mutual relationship where each participant has the same relationship to the other (i.e. spousal), a 
              @mutual attribute is used with all of the participants in that relationship listed. In the case of a directed relationship (i.e. where person X
              is the parent of person Y) both the @active and @passive attributes are used. The values allowed on the @active, @passive, and @mutual 
              attributes are URIs pointing to Syriaca.org authority files for persons. 
            </p>
            <p>
              In the context of relationships between events, this customization only allows appropriate values on @ref while excluding @ana, @active, and @passive 
              attributes.
            </p>
          </remarks>
          
        </elementSpec>

        <elementSpec ident="person" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="model.personLike"/>
          </classes>
          <content>
            <alternate>
              <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="birth" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="death" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="education" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="langKnowledge" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="nationality" minOccurs="0" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="occupation" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="residence" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="socecStatus" minOccurs="0" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="state" minOccurs="1" maxOccurs="1"/>
              </sequence>
              <sequence preserveOrder="true">
                <elementRef key="persName" minOccurs="1" maxOccurs="1"/>
                <elementRef key="trait" minOccurs="0" maxOccurs="1"/>
              </sequence>
            </alternate>
          </content>
          <remarks>
            <p>
              The <gi>person</gi> element contains person factoid data. This customization requires the proper structure for that data.
              The first child of <gi>person</gi> must be a self-closing <gi>persName</gi> element with a @ref attribute containing a 
              URIs pointing to Syriaca.org authority file for a person. The next child element must be one of the following: 
              <gi>birth</gi>, <gi>death</gi>, <gi>education</gi>, <gi>langKnown</gi>, <gi>nationality</gi>, <gi>occupation</gi>, 
              <gi>residence</gi>, <gi>socecStatus</gi>, <gi>state</gi>, or <gi>trait</gi>.
            </p>
          </remarks>
          
        </elementSpec>

        <elementSpec ident="birth" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="model.personPart"/>
            <memberOf key="att.datable.w3c"/>
          </classes>
          <content>
            <sequence preserveOrder="true">
              <alternate minOccurs="0" maxOccurs="1">
                <elementRef key="date" minOccurs="1" maxOccurs="1"/>
                <elementRef key="choice" minOccurs="1" maxOccurs="1"/>
              </alternate>
              <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
              <elementRef key="note" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="from" mode="delete"/>
            <attDef ident="to" mode="delete"/>
          </attList>
          <remarks>
            <p>This customization restricts the attribute classes of the <gi>birth</gi> element to
              att.datable.w3c but excludes the @to and @from attributes. If more precise dating is
              required for a SPEAR factoid, encoder should use the <gi>date</gi> element.</p>
            <p>
              It also restricts the child elements to those dealing with dates (<gi>date</gi> or <gi>choice</gi>),
              <gi>placeName</gi>, and <gi>note</gi>.
            </p>
          </remarks>
        </elementSpec>

        <elementSpec ident="death" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="model.personPart"/>
            <memberOf key="att.datable.w3c"/>
          </classes>
          <content>
            <sequence preserveOrder="true">
              <alternate minOccurs="0" maxOccurs="1">
                <elementRef key="date" minOccurs="1" maxOccurs="1"/>
                <elementRef key="choice" minOccurs="1" maxOccurs="1"/>
              </alternate>
              <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
              <elementRef key="note" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="from" mode="delete"/>
            <attDef ident="to" mode="delete"/>
          </attList>
          <remarks>
            <p>This customization restricts the attribute classes of the <gi>death</gi> element to
              att.datable.w3c but excludes the @to and @from attributes. If more precise dating is
              required for a SPEAR factoid, encoder should use the <gi>date</gi> element.</p>
            <p>
              It also restricts the child elements to those dealing with dates (<gi>date</gi> or <gi>choice</gi>),
              <gi>placeName</gi>, and <gi>note</gi>.
            </p>
          </remarks>
        </elementSpec>

        <elementSpec ident="education" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="model.persStateLike"/>
            <memberOf key="att.datable.w3c"/>
          </classes>
          <content>
            <elementRef key="note" minOccurs="1" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="ana" mode="add" usage="req">
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ref-in-education" scheme="schematron">
                <constraint>
                  <sch:rule context="//tei:education/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="disciplineURIs" value="$ti//listURI[@type = 'fields-of-study']/uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $disciplineURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $disciplineURIs"  role="warning">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($disciplineURIs, ';  ')"/>.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          
          <remarks>
            <p>This customization restricts the attribute classes of <gi>education</gi>
              to att.datable.w3c and the @ana attribute. If more precise dating is required for a
              SPEAR factoid, the encoder should use the <gi>date</gi> element.</p>
            <p>
              It also restricts the required @ana attribute to keyword URIs in the Syriac Taxonomy that pertain to 
              fields of education.
            </p>
          </remarks>
        </elementSpec>

        <elementSpec ident="nationality" module="namesdates" mode="replace">
          <classes mode="replace">
            <memberOf key="att.datable.custom"/>
            <memberOf key="att.datable.w3c"/>
          </classes>
          <content>
            <sequence preserveOrder="true">
              <elementRef key="placeName" minOccurs="1" maxOccurs="1"/>
              <elementRef key="date" minOccurs="0" maxOccurs="1"/>
              <elementRef key="note" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
          
          <remarks>
            <p>The TEI name for the <gi>nationality</gi> element is problematic from a
              pre-Modern perspective. "Citizenship" would be preferable in one sense, yet could in
              many instances exclude subaltern people such as the enslaved. SPEAR uses the
              <gi>nationality</gi> element as a general category for people living under a particular
              jurisdiction.</p>
            <p>This customization limits the attribute classes of the
              <gi>nationality</gi> element to att.datable.custom and att.datable.w3c and removes the
              <gi>nationality</gi> element from all model classes. It also requires exactly one
              <gi>placeName</gi> child and one <gi>note</gi> child and allows an optional <gi>date</gi> child.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="residence" module="namesdates" mode="replace">
          <classes mode="replace">
            <memberOf key="att.datable.custom"/>
            <memberOf key="att.datable.w3c"/>
          </classes>
          <content>
            <sequence preserveOrder="true">
              <elementRef key="placeName" minOccurs="1" maxOccurs="1"/>
              <elementRef key="date" minOccurs="0" maxOccurs="1"/>
              <elementRef key="note" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
          <remarks>
            <p>This customization limits the attribute classes of the
              <gi>residence</gi> element to att.datable.custom and att.datable.w3c and removes the
              <gi>residence</gi> element from all model classes. It also requires exactly one
              <gi>placeName</gi> child and one <gi>note</gi> child and allows an optional <gi>date</gi> child.</p>
          </remarks>
          
        </elementSpec>

        <elementSpec ident="occupation" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="att.datable.w3c"/>
            <memberOf key="att.global.analytic"/>
          </classes>
          <content>
            <elementRef key="note" minOccurs="1" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="ana" mode="change" usage="req">
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ana-in-occupation" scheme="schematron">
                <constraint>
                  <sch:rule context="//tei:occupation/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="occupationURIs" value="$ti//listURI[@type = 'occupations']/uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $occupationURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $occupationURIs" role="warning">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($occupationURIs, ';  ')"/>.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>This customization restricts the attribute classes of <gi>occupation</gi>
              to att.datable.w3c and att.global.analytic. If more precise dating is required for a
              SPEAR factoid, the encoder should use the <gi>date</gi> element.</p>
            <p>
              It only allows <gi>note</gi> as a child element and it restricts the required @ana attribute to keyword URIs in the Syriac Taxonomy that pertain to 
              occupations.
            </p>
          </remarks>
        </elementSpec>

        <elementSpec ident="langKnowledge" module="namesdates" mode="replace">
          <content>
            <sequence preserveOrder="true">
              <elementRef key="langKnown" minOccurs="1" maxOccurs="1"/>
              <elementRef key="note" minOccurs="1" maxOccurs="1"/>
            </sequence>
          </content>
          <remarks>
            <p>
              This customization constrains the child elements under <gi>langKnowledge</gi> to include only
              <gi>langKnown</gi> and <gi>note</gi>.
            </p>
          </remarks>
          
        </elementSpec>

        <elementSpec ident="langKnown" module="namesdates" mode="change">
          <constraintSpec ident="ana-in-langKnown" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:langKnown/@ana">
                <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                <sch:let name="languageURIs" value="$ti//listURI[@type = 'languages']/uri"/>
                <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $languageURIs)]"/>
                <sch:assert test="every $i in $anaTokens satisfies $i = $languageURIs" role="warning">
                  <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                  please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($languageURIs, ';  ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="tag" mode="delete"/>
            <attDef ident="level" mode="replace" usage="opt">
              <datatype>
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="closed">
                <valItem ident="low"/>
                <valItem ident="medium"/>
                <valItem ident="high"/>
              </valList>
            </attDef>
          </attList>
          <remarks>
            <p>
              This customization allows a closed list of values on the @level attribute ("low", "medium", and "high"). 
              It also restricts the required @ana attribute to keyword URIs in the Syriac Taxonomy that pertain to 
              languages.
            </p>
          </remarks>
          
        </elementSpec>

        <elementSpec ident="socecStatus" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="att.datable.w3c"/>
            <memberOf key="att.global.analytic"/>
          </classes>
          <content>
            <elementRef key="note" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <attList>
            <attDef ident="ana" mode="change" usage="req">
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ana-in-socecStatus" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:socecStatus/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="socioeconomicStatusURIs" value="$ti//listURI[@type = 'socioeconomic-status']/uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $socioeconomicStatusURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $socioeconomicStatusURIs" role="warning">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($socioeconomicStatusURIs, ';  ')"/>.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>This customization restricts the attribute classes of <gi>socecStatus</gi>
              to att.datable.w3c and att.global.analytic. If more precise dating is required for a
              SPEAR factoid, the encoder should use the <gi>date</gi> element.</p>
            <p>
              It only allows <gi>note</gi> as a child element and it restricts the required @ana attribute to keyword URIs in the Syriac Taxonomy that pertain to 
              socioeconomic status.
            </p>
          </remarks>
          
        </elementSpec>

        <elementSpec ident="trait" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="att.datable.w3c"/>
            <memberOf key="att.global.analytic"/>
          </classes>
          <content>
            <elementRef key="note" minOccurs="1" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="type" mode="add" usage="req">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="closed">
                <valItem ident="physical">
                  <desc>used for references to a person's physical characteristics, such as hair
                    color, height, weight, physical disabilities, etc.</desc>
                  <!-- I need to update the taxonomy before I can use it to validate the corresponding @ref values. -->
                </valItem>
                <valItem ident="gender">
                  <desc>used for references to a person's gender identity (as opposed to their
                    biological sex which SPEAR does not presume to capture).</desc>
                  <!-- I need to update the taxonomy before I can use it to validate the corresponding @ref values. -->
                </valItem>
                <valItem ident="ethnicLabel">
                  <desc>used for references to an ethnic label claimed by a person or ascribed to a
                    person; such as "Goth," "Saracen," etc.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="ana" mode="change" usage="req">
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ana-in-trait" scheme="schematron">
                <constraint>
                  <sch:rule context="tei:trait[@type='ethnicLabel']/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="ethnicLabelURIs" value="$ti//listURI[@type = 'ethnicity']/uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $ethnicLabelURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $ethnicLabelURIs" role="warning">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($ethnicLabelURIs, ';  ')"/>.</sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:trait[@type='gender']/@ana">
                    <sch:assert test="every $i in (tokenize(., ' ')) satisfies $i = 'http://syriaca.org/keyword/eunuch' or $i = 'http://syriaca.org/keyword/female' or $i = 'http://syriaca.org/keyword/male' or $i = 'http://syriaca.org/keyword/nun-as-monk'"  role="warning">
                      Preferred values for the @ana attribute on a &lt;trait&gt; element
                      @type="gender" are:
                      "http://syriaca.org/keyword/eunuch"; "http://syriaca.org/keyword/female";
                      "http://syriaca.org/keyword/male"; and
                      "http://syriaca.org/keyword/nun-as-monk". Use these if applicable. If one of
                      these does not apply, please use a descriptive term of your
                      choosing.</sch:assert>
                  </sch:rule>
                  <!-- I need to update the taxonomy before I can use it to validate the corresponding @ana values. -->
                  <sch:rule context="tei:trait[@type='physical']/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="taxonomyAllURIs" value="$ti//listURI[@type = 'taxonomyAllURIs']/uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $taxonomyAllURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $taxonomyAllURIs" role="warning">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. <!--If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($ethnicLabelURIs, ';  ')"/>-->.
                    </sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>This customization restricts the attribute classes of <gi>trait</gi>
              to att.datable.w3c and att.global.analytic. If more precise dating is required for a
              SPEAR factoid, the encoder should use the <gi>date</gi> element.</p>
            <p>
              It only allows <gi>note</gi> as a child element. It restricts the required @type attribute to the values
              "physical", "gender", and "ethnicLabel". It restricts the required @ana attribute to keyword URIs in the 
              Syriac Taxonomy that pertain to each of these three types.
            </p>
          </remarks>
          
          
          
        </elementSpec>

        <elementSpec ident="back" module="textstructure" mode="change">
          <content>
            <elementRef key="listBibl" minOccurs="1" maxOccurs="1"/>
          </content>
          <remarks>
            <p>
              The <gi>back</gi> element must contain only one <gi>listBibl</gi>.
            </p>
          </remarks>
        </elementSpec>

        <elementSpec ident="listBibl" module="core" mode="change">
          <content>
            <elementRef key="head" minOccurs="1" maxOccurs="1"/>
            <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <remarks>
            <p>
              The <gi>listBibl</gi> element must contain a <gi>head</gi> and at least
              one <gi>bibl</gi>.
            </p>
          </remarks>
        </elementSpec>

        <elementSpec ident="head" module="core" mode="change">
          <constraintSpec ident="head-in-listBibl" scheme="schematron">
            <constraint>
              <sch:rule context="tei:sourceDesc//tei:head">
                <sch:assert
                  test="normalize-space(.) = 'Sources for the Data in this Born Digital Prosopography'"
                  > A &lt;head&gt; element inside the &lt;sourceDesc&gt; must contain the text node:
                  "Sources for the Data in this Born Digital Prosopography". </sch:assert>
              </sch:rule>
              <sch:rule context="tei:back//tei:head">
                <sch:assert test="normalize-space(.) = 'Works Cited'"> A &lt;head&gt; element inside
                  the &lt;back&gt; must contain the text node: "Works Cited". </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>
              When the child of <gi>sourceDesc</gi>, <gi>head</gi> must contain "Sources for the Data in this Born Digital Prosopography".
              When the child of <gi>back</gi>, <gi>head</gi> must contain "Works Cited".
            </p>
          </remarks>
        </elementSpec>

        <elementSpec ident="state" module="namesdates" mode="change">
          <classes mode="replace">
            <memberOf key="att.datable.w3c"/>
            <memberOf key="att.global.analytic"/>
          </classes>
          <content>
            <elementRef key="note" minOccurs="1" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="ana" mode="change" usage="req">
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec ident="ana-in-state" scheme="schematron">
                <!-- Add schematron rule to validate religious affiliation against the taxonomy. Taxonomy requires updating before this can be done. -->
                <constraint>
                  <sch:rule context="tei:state[@type='mental']/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="mentalStateURIs" value="$ti//listURI[@type = 'mental-states']/uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $mentalStateURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $mentalStateURIs" role="warning">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($mentalStateURIs, ';  ')"/>.</sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:state[@type='sanctity']/@ana">
                    <sch:let name="anaTokens" value="tokenize(., ' ')"/>
                    <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                    <sch:let name="sanctityURIs" value="$ti//listURI[@type = 'sanctity']/uri"/>
                    <sch:let name="errors" value="for $i in $anaTokens return $i[not(. = $sanctityURIs)]"/>
                    <sch:assert test="every $i in $anaTokens satisfies $i = $sanctityURIs" role="warning">
                      <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not in the Taxonomy. If you find no appropriate concept on the following list, 
                      please choose a keyword of your own for the editors to consider: <sch:value-of select="string-join($sanctityURIs, ';  ')"/>.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="type" mode="add" usage="req">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="closed">
                <valItem ident="mental">
                  <desc>used for references to a person's mental traits; such as intelligence,
                    mental disability, wisdom, etc.</desc>
                </valItem>
                <valItem ident="religiousAffiliation">
                  <desc>used for references to a person's religious affiliation; including but 
                    not limited to membership in an organization, adhering to a set of beliefs, 
                    or identifying with a religious community in some way.</desc>
                </valItem>
                <valItem ident="sanctity">
                  <desc>used for references to a person's sanctity.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <remarks>
            <p>This customization restricts the attribute classes of <gi>state</gi>
              to att.datable.w3c and att.global.analytic. If more precise dating is required for a
              SPEAR factoid, the encoder should use the <gi>date</gi> element.</p>
            <p>
              It only allows <gi>note</gi> as a child element. It restricts the required @type attribute to the values
              "mental", "religiousAffiliation", and "sanctity". It restricts the required @ana attribute to keyword URIs in the 
              Syriac Taxonomy that pertain to each of these three types.
            </p>
          </remarks>
          
        </elementSpec>
    </schemaSpec>


    </body>
  </text>
</TEI>
